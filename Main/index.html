<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #info,
        #controls {
            position: absolute;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }

        #info {
            top: 10px;
            left: 10px;
        }

        #controls {
            bottom: 20px;
            left: 20px;
        }

        #markerPopup {
            display: none;
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            z-index: 200;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3>3D Earth Map</h3>
        <p>Interactive 3D Earth with texture mapping</p>
    </div>
    <div id="controls">
        <strong>Controls:</strong><br>
        Mouse: Rotate | Scroll: Zoom | Drag: Pan
    </div>
    <div id="markerPopup"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const earthGeometry = new THREE.SphereGeometry(2, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load('/resources/img/2k_earth_daymap.jpg');
        earthTexture.wrapS = earthTexture.wrapT = THREE.RepeatWrapping;
        const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture, shininess: 100 });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.castShadow = true;
        earth.receiveShadow = true;
        scene.add(earth);

        const starsGeometry = new THREE.BufferGeometry();
        const starVertices = Array.from({ length: 10000 * 3 }, () => (Math.random() - 0.5) * 200);
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        const markers = [];

        function latLngToVector3(lat, lng, radius = 2) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function createMarker(lat, lng, label = '', color = 0xff0000) {
            const texture = new THREE.TextureLoader().load('/resources/img/RedDot.svg');
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthWrite: false
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.3, 0.3, 1);

            const position = latLngToVector3(lat, lng, 2.05);
            sprite.position.copy(position);

            sprite.userData = { lat, lng, label };
            return sprite;
        }

        function addMarker(lat, lng, label = '', color = 0xff0000) {
            const marker = createMarker(lat, lng, label, color);
            markers.push(marker);
            scene.add(marker);

            // Animate drop effect
            marker.scale.set(0.01, 0.01, 1);
            let t = 0;
            function animateDrop() {
                if (t < 1) {
                    t += 0.05;
                    const s = THREE.MathUtils.lerp(0.01, 0.3, t);
                    marker.scale.set(s, s, 1);
                    requestAnimationFrame(animateDrop);
                }
            }
            animateDrop();

            return marker;
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const popup = document.getElementById('markerPopup');

        function showMarkerPopup(text, worldPosition) {
            const screenPos = worldPosition.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (1 - (screenPos.y * 0.5 + 0.5)) * window.innerHeight;

            popup.textContent = text;
            popup.style.display = 'block';
            popup.style.left = `${x}px`;
            popup.style.top = `${y - 30}px`;

            setTimeout(() => popup.style.display = 'none', 4000);
        }

        function focusCameraOn(targetPos) {
            const startPos = camera.position.clone();
            const target = targetPos.clone().normalize().multiplyScalar(4);
            let t = 0;
            const duration = 50;
            function animateFocus() {
                if (t < 1) {
                    t += 1 / duration;
                    camera.position.lerpVectors(startPos, target, t);
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    requestAnimationFrame(animateFocus);
                }
            }
            animateFocus();
        }

        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(markers, true);
            if (intersects.length > 0) {
                const marker = intersects[0].object;
                if (marker.userData) {
                    showMarkerPopup(marker.userData.label, marker.position);
                    focusCameraOn(marker.position);
                }
            }
        });

        // Mouse control logic
        let isMouseDown = false, prevX = 0, prevY = 0;
        let rotationX = 0, rotationY = 0, autoRotate = true;

        renderer.domElement.addEventListener('mousedown', e => {
            isMouseDown = true;
            prevX = e.clientX;
            prevY = e.clientY;
            autoRotate = false;
        });

        renderer.domElement.addEventListener('mouseup', () => isMouseDown = false);

        renderer.domElement.addEventListener('mousemove', e => {
            if (isMouseDown) {
                rotationY += (e.clientX - prevX) * 0.01;
                rotationX += (e.clientY - prevY) * 0.01;
                prevX = e.clientX;
                prevY = e.clientY;
            }
        });

        renderer.domElement.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.z = Math.max(3, Math.min(15, camera.position.z + e.deltaY * 0.01));
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate) {
                earth.rotation.y += 0.005;
                stars.rotation.y += 0.0005;
            } else {
                earth.rotation.x = rotationX;
                earth.rotation.y = rotationY;
            }

            markers.forEach(marker => {
                const { lat, lng } = marker.userData;
                const pos = latLngToVector3(lat, lng, 2.05);
                pos.applyEuler(earth.rotation);
                marker.position.copy(pos);
            });

            renderer.render(scene, camera);
        }

        animate();

        fetch('get_markers.php')
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    data.markers.forEach(({ lat, lng, label }) => {
                        addMarker(lat, lng, label);
                    });
                    console.log(`Loaded ${data.markers.length} markers from database`);
                } else {
                    console.error('Failed to load markers:', data.error);
                }
            })
            .catch(err => console.error('Fetch error:', err));
    </script>
</body>

</html>